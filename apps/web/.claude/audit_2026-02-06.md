# Code Audit: Session 6 Changes
**Date:** 2026-02-06
**Scope:** Inventory management, pricing, notifications, vendor UI

---

## EFFICIENCY ISSUES

### E1. Sequential DB Calls in Inventory Loop
**File:** `checkout/success/route.ts` (lines 107-155)
**Severity:** Medium

**Problem:**
For each listing in an order, we make 3 sequential DB calls:
1. SELECT listing + vendor_profile
2. UPDATE quantity
3. INSERT notification (conditional)

For an order with 5 different listings = 15 DB round trips.

**Impact:** Adds 50-150ms latency per listing to checkout success.

**Fix:** Batch operations - fetch all listings in one query, use Promise.all for updates.

---

### E2. Duplicate Order Fetch
**File:** `checkout/success/route.ts` (lines 38-42, 178-203)
**Severity:** Low

**Problem:**
- First fetch: `select('platform_fee_cents')` for payment record
- Second fetch: Full order with items for response

**Impact:** Extra DB round trip (~20ms).

**Fix:** Fetch full order once at the start, reuse for both purposes.

---

### E3. Multiple Count Queries on Dashboard
**File:** `vendor/dashboard/page.tsx` (lines 65-95)
**Severity:** Low

**Problem:**
Three separate count queries:
- draftCount
- outOfStockCount
- lowStockCount

**Impact:** 3 DB round trips instead of 1 (~60ms extra).

**Fix:** Single query with conditional aggregation:
```sql
SELECT
  COUNT(*) FILTER (WHERE status = 'draft') as draft_count,
  COUNT(*) FILTER (WHERE status = 'published' AND quantity = 0) as out_of_stock,
  COUNT(*) FILTER (WHERE status = 'published' AND quantity > 0 AND quantity <= 5) as low_stock
FROM listings WHERE vendor_profile_id = ? AND deleted_at IS NULL
```

---

### E4. Duplicate Offering Fetch in Market Box
**File:** `buyer/market-boxes/route.ts` (lines 185-207, 277-283)
**Severity:** Low

**Problem:**
- First query fetches offering details
- Second query fetches just vertical_id for redirect URLs

**Impact:** Extra DB round trip.

**Fix:** Include `market:markets(vertical_id)` in the first query.

---

## STABILITY ISSUES

### S1. Race Condition on Inventory Decrement (CRITICAL)
**File:** `checkout/success/route.ts` (lines 109-120)
**Severity:** HIGH

**Problem:**
```typescript
// Current: Read-then-write pattern
const { data: listing } = await serviceClient.from('listings').select('quantity')...
const newQuantity = Math.max(0, listing.quantity - quantityPurchased)
await serviceClient.from('listings').update({ quantity: newQuantity })...
```

Two simultaneous checkouts for the same item:
1. Both read quantity = 10
2. Both calculate newQuantity = 8
3. Both write quantity = 8
4. Result: 4 items sold, only 2 decremented

**Impact:** Inventory counts become inaccurate. Items can be oversold.

**Fix:** Use atomic decrement with RPC or raw SQL:
```sql
UPDATE listings SET quantity = GREATEST(0, quantity - $1) WHERE id = $2 RETURNING quantity
```

---

### S2. Non-Atomic Multi-Step Operations
**File:** `checkout/success/route.ts` (lines 68-156)
**Severity:** Medium

**Problem:**
Sequential operations without transaction:
1. Insert payment record
2. Decrement inventory (loop)
3. Insert notifications (loop)

If step 2 fails mid-way, some inventory decremented, some not.

**Impact:** Inconsistent state on partial failures.

**Fix:** Consider wrapping in a database transaction, or make operations idempotent and retriable.

---

### S3. Silent Notification Failures
**File:** `checkout/success/route.ts` (lines 133-150)
**Severity:** Low

**Problem:**
```typescript
await serviceClient.from('notifications').insert({...})
// No error check
```

**Impact:** Vendors may not receive stock alerts.

**Fix:** Check for errors and log, but don't block checkout:
```typescript
const { error } = await serviceClient.from('notifications').insert({...})
if (error) console.error('[checkout/success] Failed to send notification:', error)
```

---

### S4. Possible Negative Vendor Payout
**File:** `pricing.ts` (line 73)
**Severity:** Low

**Problem:**
```typescript
vendorPayoutCents = subtotalCents - vendorPercentFeeCents - vendorFlatFeeCents
```

For an order at exactly $10 minimum:
- subtotal = 1000
- vendorPercentFee = 65
- vendorFlatFee = 15
- payout = 920 (OK)

But for edge cases with rounding, could theoretically go negative.

**Impact:** Display issues or accounting errors.

**Fix:** Add floor: `Math.max(0, subtotalCents - vendorPercentFeeCents - vendorFlatFeeCents)`

---

### S5. Duplicated LOW_STOCK_THRESHOLD Constant
**Files:**
- `checkout/success/route.ts` (line 105)
- `vendor/listings/page.tsx` (line 105)
- `vendor/dashboard/page.tsx` (line 60)

**Problem:** Same value (5) defined in 3 places.

**Impact:** If changed in one place, others get out of sync.

**Fix:** Move to `pricing.ts` or create `lib/constants/inventory.ts`.

---

## SECURITY ISSUES

### X1. Missing Rate Limiting on Success Endpoint
**File:** `checkout/success/route.ts`
**Severity:** Medium

**Problem:**
No rate limiting on GET endpoint. While idempotent for inventory (checks `existingPayment`), could be used for:
- Reconnaissance (valid session IDs)
- Log spam
- Resource exhaustion

**Impact:** Potential for abuse.

**Fix:** Add rate limiting similar to checkout/session:
```typescript
const rateLimitResult = checkRateLimit(`checkout-success:${clientIp}`, { limit: 10, windowSeconds: 60 })
```

---

### X2. Missing Rate Limiting on Market Box POST
**File:** `buyer/market-boxes/route.ts` (POST handler)
**Severity:** Medium

**Problem:**
No rate limiting. Attacker could spam checkout session creation.

**Impact:** Stripe API abuse, potential costs.

**Fix:** Add rate limiting:
```typescript
const rateLimitResult = checkRateLimit(`market-box-checkout:${clientIp}`, { limit: 3, windowSeconds: 60 })
```

---

### X3. Cart Deletion Without Order Ownership Verification
**File:** `checkout/success/route.ts` (lines 161-175)
**Severity:** Low

**Problem:**
```typescript
const { data: { user } } = await supabase.auth.getUser()
// Deletes cart for this user, but doesn't verify order belongs to this user
```

Edge case: If sessionId somehow maps to a different user's order, we'd clear the wrong cart.

**Impact:** Unlikely but possible data integrity issue.

**Fix:** Verify `order.buyer_user_id === user.id` before clearing cart.

---

### X4. Market Box Amount Not Verified Against Stripe
**File:** `buyer/market-boxes/route.ts`
**Severity:** Low

**Problem:**
We calculate `buyerTotalCents` and send to Stripe. On success callback, we should verify Stripe charged the expected amount.

**Impact:** Price manipulation if Stripe session is tampered with (unlikely given Stripe's security).

**Fix:** On success, compare `session.amount_total` with expected amount.

---

## IMPLEMENTATION PLAN

### Phase 1: Critical Fixes (Do First)

#### 1.1 Fix Race Condition (S1)
Create database function for atomic decrement:
```sql
CREATE OR REPLACE FUNCTION decrement_listing_quantity(
  p_listing_id UUID,
  p_quantity INTEGER
) RETURNS TABLE(new_quantity INTEGER, title TEXT, vendor_user_id UUID) AS $$
  UPDATE listings l
  SET quantity = GREATEST(0, COALESCE(quantity, 0) - p_quantity)
  WHERE id = p_listing_id AND quantity IS NOT NULL
  RETURNING quantity, title, (SELECT user_id FROM vendor_profiles WHERE id = l.vendor_profile_id)
$$ LANGUAGE sql;
```

Update checkout/success to use RPC call.

#### 1.2 Add Rate Limiting (X1, X2)
Add to both endpoints:
```typescript
import { checkRateLimit, getClientIp, rateLimitResponse } from '@/lib/rate-limit'

const clientIp = getClientIp(request)
const rateLimitResult = checkRateLimit(`endpoint:${clientIp}`, { limit: N, windowSeconds: 60 })
if (!rateLimitResult.success) return rateLimitResponse(rateLimitResult)
```

### Phase 2: Stability Improvements

#### 2.1 Centralize LOW_STOCK_THRESHOLD
Create `lib/constants/inventory.ts`:
```typescript
export const LOW_STOCK_THRESHOLD = 5
```

Update all 3 files to import from there.

#### 2.2 Add Error Handling to Notifications (S3)
Wrap notification inserts with error logging.

#### 2.3 Floor Vendor Payout (S4)
Update `pricing.ts` line 73.

### Phase 3: Efficiency Improvements

#### 3.1 Batch Inventory Operations (E1)
After fixing race condition with RPC, call it in parallel:
```typescript
await Promise.all(
  Array.from(quantityByListing).map(([listingId, qty]) =>
    serviceClient.rpc('decrement_listing_quantity', { p_listing_id: listingId, p_quantity: qty })
  )
)
```

#### 3.2 Combine Dashboard Queries (E3)
Create RPC or use raw query with FILTER aggregates.

#### 3.3 Fix Duplicate Fetches (E2, E4)
Minor refactors to reuse query results.

---

## PLAN AUDIT: Potential Issues

### Risk 1: RPC Function Migration
**Concern:** New database function requires migration.
**Mitigation:** Test in dev first. Function is additive (doesn't break existing code).

### Risk 2: Rate Limiting False Positives
**Concern:** Legitimate users hitting rate limits.
**Mitigation:**
- checkout-success: 10/min is generous (user typically hits once)
- market-box: 3/min is reasonable for purchase attempts

### Risk 3: Batch Operations Failure Mode
**Concern:** If Promise.all fails, some decrements happen, some don't.
**Mitigation:** Each RPC call is independent. Consider using `Promise.allSettled` and logging failures.

### Risk 4: Centralized Constant Breaking Imports
**Concern:** Changing import paths could break builds.
**Mitigation:** Simple search/replace. TypeScript will catch any missed imports.

---

## RECOMMENDED PRIORITY

1. **S1 (Race Condition)** - Critical, fix immediately
2. **X1, X2 (Rate Limiting)** - Important security, do with S1
3. **S5 (Duplicate Constant)** - Easy win, prevents future bugs
4. **S3 (Notification Errors)** - Quick fix
5. **S4 (Floor Payout)** - Quick fix
6. **E1, E3 (Batching)** - Nice to have, can defer
7. **E2, E4 (Duplicate Fetches)** - Minor, can defer
